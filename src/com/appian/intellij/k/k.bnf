{
  parserClass="com.appian.intellij.k.parser.KParser"
  extends="com.appian.intellij.k.KAstWrapperPsiElement"

  psiClassPrefix="K"
  psiImplClassSuffix="Impl"
  psiPackage="com.appian.intellij.k.psi"
  psiImplPackage="com.appian.intellij.k.psi.impl"

  elementTypeHolderClass="com.appian.intellij.k.psi.KTypes"
  elementTypeClass="com.appian.intellij.k.psi.KElementType"
  tokenTypeClass="com.appian.intellij.k.psi.KTokenType"

  psiImplUtilClass="com.appian.intellij.k.psi.impl.KPsiImplUtil"

  tokens=[

    // ascii chars
    bang='!'
    quote='"'
    hash='#'
    dollar='$'
    percent='%'
    ampersand='&'
    open_paren='('
    close_paren=')'
    asterisk='*'
    plus='+'
    comma=','
    dash='-'
    period='.'
    colon=':'
    semicolon=';'
    less_than='<'
    equals='='
    greater_than='>'
    question_mark='?'
    at='@'
    open_bracket='['
    close_bracket=']'
    caret='^'
    underscore='_'
    back_tick='`'
    open_brace='{'
    pipe='|'
    close_brace='}'
    tilde='~'

    verb="regexp:[!#$%&*+,-.<=>?@\^_|~]"

    // adverbs
    slash='/'
    slash_colon='/:'
    back_slash='\'
    back_slash_colon='\:'
    tick="'"
    tick_colon="':"
    adverb="regexp:/ | /: | \\ | \\: | ' | ':"
    composed_monad="composed_monad"
    derived_verb="derived_verb"

    // names
    user_identifier='regexp:[a-zA-Z][._a-zA-Z0-9]*'
    system_identifier='regexp:_[._a-zA-Z0-9]*|[0-6]:'

    // nouns
    number='regexp:((0|[1-9]\d*)(\.\d+)?([eE][+-]?\d*)?|0[iInN])'
    char='regexp:"(\\"|[^"])"'
    string='regexp:"(\\"|[^"])*"'
    symbol_vector="symbol_vector"
    number_vector="number_vector"

    // commands
    command_name='regexp:\s*\\[dl]'

    // i/o, dynamic load and client/server
    n_colon='regexp:[0-6]:'

    // control
    if="if"
    do="do"
    while="while"

    // punctuation
    newline='regexp:\r|\n|\r\n'
    comment='comment'
  ]
}

root ::= E0+ separator_or_eof
private E0 ::= top_level_assignment
             | command
             | E1
             | E5
             | E6
private E1 ::= separator
             | expression
private E2 ::= separator
             | E3
private E3 ::= E4
             | E6
private E4 ::= expression
             | E5
private E5 ::= verb+
             | composed_monad
             | derived_verb
private E6 ::= colon [colon]
             | n_colon

private separator ::= semicolon | newline
private separator_or_eof ::= separator | <<eof>>

group ::= open_paren E3 close_paren

user_id ::= user_identifier {
  mixin="com.appian.intellij.k.psi.impl.KNamedElementImpl"
  implements="com.appian.intellij.k.psi.KNamedElement"
  methods=[getName setName getNameIdentifier getPresentation]
}

expression ::= signal | trace | assignment | fn_call | noun
private fn_call ::= infix_fn_call | monad_fn_call | mixed_fn_call
// this rule is written this way for parsing performance (reuse as much work as possible)
// if you change anything about it, make sure performance is not affected
private mixed_fn_call ::= (prefix_fn_call | callable) [(infix_fn [E3]) | expression]
monad_fn_call ::= monad_fn monad_arg
monad_fn ::= verb | derived_verb | composed_monad | n_colon | colon
monad_arg ::= E3

private noun ::= vector | atom
private callable ::= user_id | system_identifier | fn_and_index_target [index+]

private fn_and_index_target ::= symbol | string | vector | lambda | list | group

private vector ::= symbol_vector | number_vector // string is not a vector-only noun b/c it can be indexed
private atom ::= number | char // symbol is not atomic-only b/c it can be indexed

list ::= open_paren ([E3] separator [E3])* close_paren
lambda ::= open_brace [lambda_params] E1* close_brace
lambda_params ::= open_bracket [user_id (separator user_id)*] close_bracket
prefix_fn ::= (control | derived_verb | verb | user_id | system_identifier)
prefix_fn_call ::= prefix_fn prefix_fn_args index*
prefix_fn_args ::= open_bracket E2* close_bracket
index ::= open_bracket E2* close_bracket
private control ::= (colon | if | do | while)

infix_fn_call ::= noun infix_fn [E3]
infix_fn ::= (infixNoIndex | infixIndex) [adverb]
private infixNoIndex ::= n_colon
private infixIndex ::= (verb | adverb | system_identifier | derived_verb) [index]

private assignment ::= global_assignment | local_assignment | compound_assignment
global_assignment ::= user_id colon colon E4
local_assignment ::= user_id colon E4
compound_assignment ::= user_id [index] [verb] colon E4
top_level_assignment ::= user_id colon [colon] E4

signal ::= tick expression
trace ::= back_slash expression
command ::= command_name (user_id | "^")
