{
  parserClass="com.appian.intellij.k.parser.KParser"
  extends="com.appian.intellij.k.KAstWrapperPsiElement"

  psiClassPrefix="K"
  psiImplClassSuffix="Impl"
  psiPackage="com.appian.intellij.k.psi"
  psiImplPackage="com.appian.intellij.k.psi.impl"

  elementTypeHolderClass="com.appian.intellij.k.psi.KTypes"
  elementTypeClass="com.appian.intellij.k.psi.KElementType"
  tokenTypeClass="com.appian.intellij.k.psi.KTokenType"

  psiImplUtilClass="com.appian.intellij.k.psi.impl.KPsiImplUtil"

  tokens=[

    // ascii chars
    bang='!'
    quote='"'
    hash='#'
    dollar='$'
    percent='%'
    ampersand='&'
    open_paren='('
    close_paren=')'
    asterisk='*'
    plus='+'
    comma=','
    dash='-'
    period='.'
    colon=':'
    semicolon=';'
    less_than='<'
    equals='='
    greater_than='>'
    question_mark='?'
    at='@'
    open_bracket='['
    close_bracket=']'
    caret='^'
    underscore='_'
    back_tick='`'
    open_brace='{'
    pipe='|'
    close_brace='}'
    tilde='~'

    verb="verb"

    // adverbs
    adverb="adverb"

    // names
    user_identifier="user_identifier"
    k3_system_function="k3_system_function"
    q_system_function="q_system_function"

    // nouns
    number="number"
    char="char"
    string="string"
    symbol_vector="symbol_vector"
    number_vector="number_vector"

    // commands
    current_namespace="current_namespace"
    simple_command="simple_command"
    complex_command="complex_command"

    // special
    trace='\'
    signal="signal"
    evaluation_context="evaluation_context"

    // control
    flow_control="flow_control"

    // punctuation
    newline="newline"
    comment='comment'
  ]
}

// E:E;e|e e:nve|te| t:n|v v:tA|V n:t[E]|(E)|{E}|N
root ::= top+ separator_or_eof
private top ::= namespace_definition
              | command
              | explicit_k_or_q_eval
              | expression_list
private expression_list ::= separator | expression (separator+ expression)*
expression ::= Noun_or_Verb Noun_or_Verb? adverb? expression?
private Noun_or_Verb ::= Noun | Verb
private Noun ::= control
            | args // there can be standalone args: e.g. (`.fn;[])
            | group_or_list
            | noun
            | any_assignment
            | id

control ::= flow_control args
args ::= open_bracket expression_list* close_bracket

private Verb ::= verb [colon] | system_function | signal | trace | colon
private system_function ::= k3_system_function | q_system_function
group_or_list ::= open_paren expression_list* close_paren

lambda ::= open_brace [lambda_params] expression_list* close_brace
lambda_params ::= open_bracket [user_id (separator user_id)*] close_bracket

private separator ::= semicolon | newline
private separator_or_eof ::= separator | <<eof>>

// always defined at root
command ::= simple_command (user_id|number|number_vector|caret) | complex_command (number|expression)
namespace_definition ::= current_namespace user_id
explicit_k_or_q_eval ::= evaluation_context expression

// assignment
private any_assignment ::= assignment | compound_assignment
assignment ::= user_id colon [colon]
compound_assignment ::= user_id [compound_assignment_index] [verb] colon
compound_assignment_index ::= open_bracket expression close_bracket

// all data are syntactically nouns
private noun ::= vector | atom | lambda
private vector ::= symbol_vector | number_vector | string
private atom ::= symbol | number | char

private id ::= user_id | k3_system_function
user_id ::= (user_identifier | q_system_function) {
  mixin="com.appian.intellij.k.psi.impl.KNamedElementImpl"
  implements="com.appian.intellij.k.psi.KNamedElement"
  methods=[getName setName getNameIdentifier getPresentation]
}
